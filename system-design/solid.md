## SOLID原则

### Single Responsibility Principle：单一职责原则

一个类只负责一个职责，或者一个类应该只有一个发生变化的原因。

事实上，实际情况中，类的单一职责是比较难保证的。通常，接口和方法的单一职责更容易实现。

### Open/Close（开闭原则）

一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。

对扩展开放，指的是当我们需要添加一个新功能的时候，只需要添加类或者模块，而尽可能少的修改原有的功能。对修改关闭，当需要修改一部分功能时，也需要尽量少修改，修改的时候尽量保留原来的代码，扩展出新的功能。

### Liskov Substitution Principle（里氏替换原则）

所有引用基类的地方必须能透明地使用其子类的对象。个人理解是所有引用基类的地方，替换成任何实现类都可以。

要理解里氏替换，可以先理解这样一个例子：

鸟会飞，所以对于类Bird有方法"fly"，在大众的认知中，企鹅也属于鸟，所以将企鹅的类继承了鸟。但是企鹅并不会飞，在基类bird.fly的地方，替换成企鹅将会出现问题，因此，它违反了里氏替换原则。

里氏替换主要关注的是“是否需要继承”或者“是否应该继承”的问题。为了实现LSP，在实现继承的时候，子类方法的可见性必须等于或者大于超类方法的可见性，子类方法抛出的异常只能是超类中对应方法所抛出异常的子类。同时，子类不应该覆盖超类的方法，如果覆盖了，应该提取出新的子类。

### Law of Demeter（迪米特法则）

又叫最少知识原则（Least Knowledge Principle），指一个对象应该尽可能少的了解，不和陌生人说话。

一个类应该尽量少的暴露自己的方法，调用者只需要关注方法本身的功能，至于内部细节，调用者并不关心。

### Interface Segregation Principle（接口分离原则）

对于一个接口，如果一个实现类不需要其中的一个方法，则可以考虑将接口进行进一步的拆分。

### Dependency Inversion Principle （依赖倒置原则）

1. 上层模块不应该依赖底层模块，它们都应该依赖于抽象。
2. 抽象不应该依赖细节
3. 细节应该依赖抽象

在java中就是：

1. 类/模块之间的依赖通过接口/抽象类发生，实现类之间不应发生直接依赖
2. 接口的设计不应该依赖实现类的细节
3. 实现类应该依赖接口的设计

### 小结

SOLID的几个原则相互联系，但各自的重点不同，在方法/类/功能模块/架构的设计中可以作为参考。单一职责原则和接口分离原则更重类设计上的简洁及功能间的解耦，里氏替换原则重继承关系的把握，迪米特重封装，依赖倒置关注类之间引用关系的设计。最终目的是对系统解耦合，以达到易维护、可扩展的目的。